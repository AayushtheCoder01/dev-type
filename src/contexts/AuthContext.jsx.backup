import { createContext, useContext, useState, useEffect } from 'react'
import { supabase } from '../lib/supabase'
import { getUserProfile, updateUserProfile, migrateLocalStorageToSupabase } from '../lib/supabaseHelpers'

const AuthContext = createContext()

const AUTH_STORAGE_KEY = 'codetype_auth'
const USERS_STORAGE_KEY = 'codetype_users'

export const AuthProvider = ({ children }) => {
  const [currentUser, setCurrentUser] = useState(null)
  const [loading, setLoading] = useState(true)
  const [useSupabase, setUseSupabase] = useState(false)

  // Check if Supabase is available
  useEffect(() => {
    const checkSupabase = async () => {
      try {
        const { data, error } = await supabase.from('user_profiles').select('count').limit(1)
        if (!error) {
          setUseSupabase(true)
          const { data: { session } } = await supabase.auth.getSession()
          if (session?.user) {
            await loadUserProfileFromSupabase(session.user.id)
          } else {
            loadUserFromLocalStorage()
          }
        } else {
          loadUserFromLocalStorage()
        }
      } catch (err) {
        console.log('Using localStorage mode')
        loadUserFromLocalStorage()
      }
      setLoading(false)
    }
    checkSupabase()
  }, [])

  useEffect(() => {
    if (!useSupabase) return

    const { data: { subscription } } = supabase.auth.onAuthStateChange(async (_event, session) => {
      if (session?.user) {
        await loadUserProfileFromSupabase(session.user.id)
      } else {
        setCurrentUser(null)
      }
    })

    return () => subscription.unsubscribe()
  }, [useSupabase])

  const loadUserFromLocalStorage = () => {
    const savedAuth = localStorage.getItem(AUTH_STORAGE_KEY)
    if (savedAuth) {
      const authData = JSON.parse(savedAuth)
      setCurrentUser(authData.user)
    }
  }

  const loadUserProfileFromSupabase = async (userId) => {
    try {
      const profile = await getUserProfile(userId)
      if (!profile) {
        loadUserFromLocalStorage()
        return
      }
      
      const user = {
        id: profile.id,
        email: profile.email,
        username: profile.username,
        displayName: profile.display_name,
        xp: profile.xp,
        level: profile.level,
        stats: {
          totalSessions: profile.total_sessions,
          totalTime: profile.total_time,
          avgWpm: profile.avg_wpm,
          avgAccuracy: profile.avg_accuracy,
          favoriteLanguage: profile.favorite_language,
        },
        bestWpm: profile.best_wpm,
        bestAccuracy: profile.best_accuracy,
        currentStreak: profile.current_streak,
        longestStreak: profile.longest_streak,
      }
      setCurrentUser(user)
      localStorage.setItem(AUTH_STORAGE_KEY, JSON.stringify({ user }))
    } catch (error) {
      console.log('Using localStorage fallback')
      loadUserFromLocalStorage()
    }
  }

  const signup = async (email, password, username) => {
    try {
      // Always create in localStorage first
      const usersData = localStorage.getItem(USERS_STORAGE_KEY)
      const users = usersData ? JSON.parse(usersData) : []

      const existingUser = users.find(u => u.email === email)
      if (existingUser) {
        return { success: false, error: 'User with this email already exists' }
      }

      const newUser = {
        id: Date.now().toString(),
        email,
        username: username || email.split('@')[0],
        password,
        createdAt: new Date().toISOString(),
        xp: 0,
        stats: {
          totalSessions: 0,
          totalTime: 0,
          avgWpm: 0,
          avgAccuracy: 0,
          favoriteLanguage: null,
          languagesPracticed: []
        },
        preferences: {
          languages: [],
          theme: 'dark'
        }
      }

      users.push(newUser)
      localStorage.setItem(USERS_STORAGE_KEY, JSON.stringify(users))

      const { password: _, ...userWithoutPassword } = newUser
      setCurrentUser(userWithoutPassword)
      localStorage.setItem(AUTH_STORAGE_KEY, JSON.stringify({ user: userWithoutPassword }))

      // Try Supabase in background (don't block on errors)
      if (useSupabase) {
        supabase.auth.signUp({
          email,
          password,
          options: {
            data: {
              username: username || email.split('@')[0],
              display_name: username || email.split('@')[0],
            },
          },
        }).then(({ data }) => {
          if (data?.user) {
            const hasLocalData = localStorage.getItem('codetype_test_history')
            if (hasLocalData) {
              migrateLocalStorageToSupabase(data.user.id)
            }
          }
        }).catch(err => console.log('Supabase signup skipped:', err.message))
      }

      return { success: true, user: userWithoutPassword }
    } catch (error) {
      return { success: false, error: error.message }
    }
  }

  const login = async (email, password) => {
    try {
      const usersData = localStorage.getItem(USERS_STORAGE_KEY)
      const users = usersData ? JSON.parse(usersData) : []

      const user = users.find(u => u.email === email && u.password === password)
      if (!user) {
        return { success: false, error: 'Invalid email or password' }
      }

      const { password: _, ...userWithoutPassword } = user
      setCurrentUser(userWithoutPassword)
      localStorage.setItem(AUTH_STORAGE_KEY, JSON.stringify({ user: userWithoutPassword }))

      // Try Supabase in background
      if (useSupabase) {
        supabase.auth.signInWithPassword({ email, password })
          .then(({ data }) => {
            if (data?.user) {
              loadUserProfileFromSupabase(data.user.id)
              const hasLocalData = localStorage.getItem('codetype_test_history')
              if (hasLocalData) {
                migrateLocalStorageToSupabase(data.user.id)
              }
            }
          })
          .catch(err => console.log('Supabase login skipped:', err.message))
      }

      return { success: true, user: userWithoutPassword }
    } catch (error) {
      return { success: false, error: error.message }
    }
  }

  const logout = async () => {
    try {
      if (useSupabase) {
        await supabase.auth.signOut()
      }
      setCurrentUser(null)
      localStorage.removeItem(AUTH_STORAGE_KEY)
    } catch (error) {
      console.error('Logout error:', error)
    }
  }

  const updateUserStats = async (updates) => {
    if (!currentUser) return

    const updatedUser = {
      ...currentUser,
      ...updates
    }

    setCurrentUser(updatedUser)
    localStorage.setItem(AUTH_STORAGE_KEY, JSON.stringify({ user: updatedUser }))

    // Update localStorage users list
    const usersData = localStorage.getItem(USERS_STORAGE_KEY)
    const users = usersData ? JSON.parse(usersData) : []
    const userIndex = users.findIndex(u => u.id === currentUser.id)
    
    if (userIndex !== -1) {
      users[userIndex] = { 
        ...users[userIndex], 
        ...updates,
        password: users[userIndex].password 
      }
      localStorage.setItem(USERS_STORAGE_KEY, JSON.stringify(users))
    }

    // Try Supabase in background
    if (useSupabase) {
      const dbUpdates = {}
      if (updates.xp !== undefined) dbUpdates.xp = updates.xp
      if (updates.level !== undefined) dbUpdates.level = updates.level
      if (updates.stats) {
        if (updates.stats.totalSessions !== undefined) dbUpdates.total_sessions = updates.stats.totalSessions
        if (updates.stats.totalTime !== undefined) dbUpdates.total_time = updates.stats.totalTime
        if (updates.stats.avgWpm !== undefined) dbUpdates.avg_wpm = updates.stats.avgWpm
        if (updates.stats.avgAccuracy !== undefined) dbUpdates.avg_accuracy = updates.stats.avgAccuracy
        if (updates.stats.favoriteLanguage !== undefined) dbUpdates.favorite_language = updates.stats.favoriteLanguage
      }

      updateUserProfile(currentUser.id, dbUpdates).catch(err => 
        console.log('Supabase sync skipped:', err.message)
      )
    }
  }

  const value = {
    currentUser,
    loading,
    signup,
    login,
    logout,
    updateUserStats,
  }

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  )
}

export const useAuth = () => {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider')
  }
  return context
}
